result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(36)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.tra <- D.discretization.RST(wine.decTable, type.method = "global.discernibility")
str(cut.values.tra$cut.values)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
?D.discretization.RST
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
?D.discretization.RST
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "local.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
?D.discretization.RST
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "unsupervised.intervals")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
?D.discretization.RST
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "unsupervised.intervals")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
?D.discretization.RST
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "unsupervised.quantiles")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
?D.discretization.RST
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "unsupervised.quantiles")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
?D.discretization.RST
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
?FS.feature.subset.computation
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
?FS.feature.subset.computation
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "greedy.heuristic.superreduct")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
?FS.feature.subset.computation
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "greedy.heuristic.superreduct")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
## zastosowanie listy cech zawartej w redukcie do wygenerowania zestawu reguł:
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
## generowanie reduktu w oparciu o dane dyskretne, wybrana metoda "quickreduct"
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
library(RoughSets)
print(RoughSetData$pima.dt)
?RoughSetData
set.seed(6)
train.idx = sample(dim(RoughSetData$pima.dt)[1],dim(RoughSetData$pima.dt)[1]*0.62)
pima.decTable <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[train.idx, ], decision.attr = 9, indx.nominal = 9)
test <- SF.asDecisionTable(dataset = RoughSetData$pima.dt[-train.idx, -ncol(RoughSetData$pima.dt)])
test.classes = RoughSetData$pima.dt[-train.idx, ncol(RoughSetData$pima.dt)]
## Dane ciągłe wymagają dyskretyzacji, wybrany w tym celu przykładowy algorytm "global.disc"
cut.values.train <- D.discretization.RST(pima.decTable, type.method = "global.discernibility")
str(cut.values.train$cut.values)
## generate new decision table
new.decTable.train <- SF.applyDecTable(pima.decTable, cut.values.train)
new.decTable.test <- SF.applyDecTable(test, cut.values.train)
new.decTable.train
reduct <- FS.feature.subset.computation(new.decTable.train, method = "quickreduct.rst")
rules <- RI.indiscernibilityBasedRules.RST(new.decTable.train, reduct)
summary(rules)
## predicting newdata
result <- as.numeric(predict(rules, new.decTable.test)$predictions)
accuracy = sum(as.array(test.classes) == (result))/length(test.classes)*100
sprintf("Wynik klasyfikacji: %.1f proc.",accuracy)
